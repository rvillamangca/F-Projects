module Problems
open Algorithms



// PROJECT EULER PROBLEM NO. 001 - Multiples of 3 & 5 -------------------------------------

(*
    If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5,
    6 and 9. The sum of these multiples is 23. 
*)

let prob1 lim a b =
    [a; b; (-(lcm a b))] |> List.map(fun x -> x * (triGen ((lim-1)/(abs x)))) |> List.sum
    
    

// PROJECT EULER PROBLEM NO. 002 - Even Fibonacci Numbers ---------------------------------

(*
    Each new term in the Fibonacci sequence is generated by adding the previous two terms.   
    By starting with 1 and 2, the first 10 terms will be:                                    
                                                                                          
                          1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...                            
                                                                                            
    By considering the terms in the Fibonacci sequence whose values do not exceed four      
    million, find the sum of the even-valued terms.
*)

// Even third fibonacci is an even fibonacci

let prob2 lim =
    // [1 .. (fiboRank lim)] |> List.map(tFibo) |> List.filter(fun x -> (x % 2) = 0) |> List.sum
    // [3 .. 3 .. (((fiboRank lim) / 3) * 3)] |> List.map aFibo |> List.sum
    List.init ((fiboRank lim)/3+1) ((*) 3) |> List.map aFibo |> List.sum
    // [|3 .. 3 .. (((fiboRank lim) / 3) * 3)|] |> Array.Parallel.map aFibo |> Array.sum
   

// PROJECT EULER PROBLEM NO. 003 - Largest prime factor ---------------------------------

(*
    The prime factors of 13195 are 5, 7, 13 and 29. 

    What is the largest prime factor of the number 600851475143? 
*)

// Solution 1:  Using Sieve of Eratosthenes
//              Note that since the number is odd we can just sieve up to the third of it.

let prob3 lim =
    (*let ps = primeSieve (lim/3) |> List.rev
    let ss = ps |> List.toSeq |> Seq.takeWhile (fun x -> lim % x <> 0)
    ps.[ss |> Seq.length]*)

    (*let mutable p = 1L
    let mutable n = lim
    while n > p do
        p <- p + 1L
        while n % p = 0L do n <- n/p
    p*)

    let rec largestPrimeFactor (n: int64) (p: int64) =
        match n with
        | 1L -> p-1L
        | _ ->
            let rec removeFactor (x: int64) =
                match x % p with
                | 0L -> removeFactor (x/p)
                | _ -> x
            largestPrimeFactor (removeFactor n) (p+1L)
    largestPrimeFactor lim 2L